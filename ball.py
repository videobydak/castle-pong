import pygame, random, math
from config import BALL_RADIUS, WHITE, RED, YELLOW, POTION_COLORS
from typing import Optional, TYPE_CHECKING

if TYPE_CHECKING:
    from paddle import Paddle

class Ball:
    def __init__(self, x, y, vx, vy, color,
                 is_power: bool = False,
                 power_type: Optional[str] = None,
                 pierce: bool = False,
                 spin: float = 0.0,
                 force_no_spin: bool = False):
        """Create a new projectile.

        Parameters
        ----------
        x, y : float
            Initial position.
        vx, vy : float
            Initial velocity components.
        color : tuple[int, int, int]
            RGB colour used for drawing and to infer projectile type.
        is_power : bool, default False
            Whether the projectile is a potion power-up.
        power_type : Optional[str], default None
            The potion type string when *is_power* is True.
        pierce : bool, default False
            If True the projectile passes through castle blocks.
        spin : float, default 0.0
            Initial angular velocity in radians per *logic frame* (dt ≈ 1).
            Positive values correspond to clockwise rotation.
        force_no_spin : bool, default False
            If True, draw the projectile with angle=0 (no rotation).
        """
        self.pos = pygame.Vector2(x, y)
        self.prev = pygame.Vector2(x, y)
        self.vel = pygame.Vector2(vx, vy)
        self.color = color
        self.is_power = is_power
        self.power_type = power_type
        # piercing projectile flag (passes through castle blocks)
        self.pierce = pierce
        # Sticky paddle support – None or reference to Paddle instance
        self.stuck_to: Optional["Paddle"] = None
        self.stuck_offset = pygame.Vector2(0, 0)
        # Sticky cooldown: timestamp (ms) until which ball cannot re-stick
        self.sticky_cooldown_until = 0
        # Red ball tracking - how many castle blocks it has hit
        self.blocks_hit = 0
        # Ball is "friendly" (passes through castle) until first bounce
        self.friendly = False

        # --- Spin / rotation ---
        self.spin = float(spin)  # angular velocity (rad per logic frame)
        self.angle = random.random() * math.tau  # orientation angle in radians
        self.force_no_spin = force_no_spin

    def update(self, dt):
        from config import BALL_FRICTION, MAGNUS_COEFF, SPIN_DAMPING
        self.prev = self.pos.copy()
        # Integrate orientation first (makes drawing use updated angle)
        self.angle += self.spin * dt
        # --- Magnus effect – lateral force generated by spin
        if self.spin != 0 and self.vel.length_squared() > 0:
            # Perpendicular vector to velocity (rotate 90° clockwise)
            mag_vec = pygame.Vector2(-self.vel.y, self.vel.x)
            mag_vec = mag_vec.normalize() * self.spin * MAGNUS_COEFF
            self.vel += mag_vec * dt
        # (Friction and spin damping will be applied after movement – see below)

        # If ball is stuck to a paddle, follow that paddle and ignore physics
        if self.stuck_to is not None:
            # stick just outside paddle face
            p = self.stuck_to
            if p.side == 'top':
                # Stick on the castle-facing (bottom) side of the paddle
                self.pos.x = p.rect.centerx + self.stuck_offset.x
                self.pos.y = p.rect.bottom + BALL_RADIUS + 1
            elif p.side == 'bottom':
                # Castle sits above bottom paddle, so stick to its top side
                self.pos.x = p.rect.centerx + self.stuck_offset.x
                self.pos.y = p.rect.top - BALL_RADIUS - 1
            elif p.side == 'left':
                # For left paddle, castle is to the right -> use right face
                self.pos.y = p.rect.centery + self.stuck_offset.y
                self.pos.x = p.rect.right + BALL_RADIUS + 1
            else:  # right paddle
                # Castle is to the left -> use left face
                self.pos.y = p.rect.centery + self.stuck_offset.y
                self.pos.x = p.rect.left - BALL_RADIUS - 1
            # keep vel zero while stuck
            self.vel.xy = (0,0)
            # Stop spinning while stuck
            self.spin = 0
            return

        # regular motion
        self.pos += self.vel * dt

        # --- apply friction (linear) and spin damping ---
        self.vel *= BALL_FRICTION
        self.spin *= SPIN_DAMPING

    def draw(self, screen, small_font):
        x, y = int(self.pos.x), int(self.pos.y)
        size = BALL_RADIUS * 2 + 4  # +4 for antialiasing margin
        surf = pygame.Surface((size, size), pygame.SRCALPHA)
        center = size // 2
        angle_deg = math.degrees(self.angle)

        # Piercing projectile (purple glow) ------------------------
        if self.pierce:
            pygame.draw.circle(surf, (255,255,255), (center,center), BALL_RADIUS-2)
            pygame.draw.circle(surf, (170,0,255), (center,center), BALL_RADIUS, 2)
            # Draw spin marker (soft black for piercing projectiles)
            if not getattr(self, 'force_no_spin', False):
                marker_r = BALL_RADIUS - 2
                marker_angle = self.angle
                marker_pos = (
                    center + int(marker_r * math.cos(marker_angle)),
                    center + int(marker_r * math.sin(marker_angle))
                )
                marker_surf = pygame.Surface((BALL_RADIUS, BALL_RADIUS), pygame.SRCALPHA)
                pygame.draw.circle(marker_surf, (0,0,0,90), (BALL_RADIUS//2, BALL_RADIUS//2), BALL_RADIUS//4)
                surf.blit(marker_surf, (marker_pos[0]-BALL_RADIUS//2, marker_pos[1]-BALL_RADIUS//2), special_flags=pygame.BLEND_RGBA_ADD)
            rect = surf.get_rect(center=(x, y))
            screen.blit(surf, rect)
            return

        # Power-up potion -----------------------------------
        if self.is_power:
            fluid = POTION_COLORS.get(self.power_type, YELLOW)
            # Draw solid potion color as main fill
            body_rect = pygame.Rect(center-BALL_RADIUS, center-BALL_RADIUS, BALL_RADIUS*2, BALL_RADIUS*2)
            pygame.draw.ellipse(surf, fluid, body_rect)  # solid fluid fill
            # Draw glass outline
            pygame.draw.ellipse(surf, (255,255,255), body_rect, 2)
            # Draw neck (glass)
            neck_w = BALL_RADIUS // 1.2
            neck_h = BALL_RADIUS // 1.2
            neck_rect = pygame.Rect(center-neck_w//2, center-BALL_RADIUS-neck_h+2, neck_w, neck_h)
            pygame.draw.rect(surf, (220,220,220), neck_rect)

            # Draw cork (small ellipse)
            cork_w = BALL_RADIUS // 1.5
            cork_h = BALL_RADIUS // 2.5
            cork_rect = pygame.Rect(center-cork_w//2, center-BALL_RADIUS-neck_h-cork_h//2+2, cork_w, cork_h)
            pygame.draw.ellipse(surf, (180,140,80), cork_rect)
            # Rotate whole bottle for spin visual
            final = surf if getattr(self, 'force_no_spin', False) else pygame.transform.rotate(surf, -angle_deg)
            rect = final.get_rect(center=(x, y))
            screen.blit(final, rect)
            return

        # Cannonball ---------------------------------------
        if self.color == WHITE:
            dark = (80,80,80)
            mid  = (140,140,140)
            highlight = (220,220,220)
            # base circle
            pygame.draw.circle(surf, dark, (center,center), BALL_RADIUS)
            # mid tone arc
            pygame.draw.circle(surf, mid, (center-2, center-2), BALL_RADIUS-2)
            # highlight small dot rotates to indicate spin
            if not getattr(self, 'force_no_spin', False):
                marker_r = BALL_RADIUS // 3  # closer to center
                marker_angle = self.angle
                hx = center + int(marker_r * math.cos(marker_angle))
                hy = center + int(marker_r * math.sin(marker_angle))
                pygame.draw.circle(surf, highlight, (hx, hy), BALL_RADIUS//3)
            else:
                # static highlight for preview
                pygame.draw.circle(surf, highlight, (center-3, center-3), BALL_RADIUS//3)
            rect = surf.get_rect(center=(x, y))
            screen.blit(surf, rect)
            return

        # Flameball ----------------------------------------
        if self.color == RED:
            palette = [(255,0,0), (255,80,0), (255,160,0), (255,120,0)]
            core_col = random.choice(palette)
            outer_col = (150,0,0)
            pygame.draw.circle(surf, outer_col, (center,center), BALL_RADIUS)
            pygame.draw.circle(surf, core_col, (center,center), BALL_RADIUS-2)
            # Draw spin marker (flickering, soft core color)
            if not getattr(self, 'force_no_spin', False):
                marker_r = BALL_RADIUS - 2
                mx = center + int(marker_r * math.cos(self.angle))
                my = center + int(marker_r * math.sin(self.angle))
                # soft dot using flicker core color
                outer_col = core_col + (70,)
                inner_col = core_col + (180,)
                pygame.draw.circle(surf, outer_col, (mx,my), BALL_RADIUS//3)
                pygame.draw.circle(surf, inner_col, (mx,my), BALL_RADIUS//4)
            rect = surf.get_rect(center=(x, y))
            screen.blit(surf, rect)
            return

        # Fallback simple draw (no spin marker)
        pygame.draw.circle(surf, self.color, (center,center), BALL_RADIUS)
        rect = surf.get_rect(center=(x, y))
        screen.blit(surf, rect)

    def rect(self):
        return pygame.Rect(self.pos.x-BALL_RADIUS, self.pos.y-BALL_RADIUS,
                           BALL_RADIUS*2, BALL_RADIUS*2) 